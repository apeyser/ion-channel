_________________________________________________________________________

When run, the program lists a set of references relating to this
software.  The relevant references and software must be cited when
publishing results generated by this program.
_________________________________________________________________________

+ Documentation +

Documentation is in the DOC directory in txt2tags format.  This format
can be read directly or converted to HTML etc using the txt2tags program.

The 'Documentation.t2t' file contains reference information. The 
'ionch.howto.t2t' is more useful to learn how to do things with the
program.

+ Running the program +

The program reads an input file and writes files into 'dat'
(restart files) and 'res' (results files) directories. These
directories must exist before the program is run.   It takes two
optional arguments.  The first is the 'run' number and the second
is a random seed.  The first number is used to find the input file,
which is expected to be names 'channel.inp' or 'channel.XXX.inp'
where XXX is a zero filled three digit number (eg 001, 002 etc)
matching the number given on the command line.  The run number
is also used to label all the output files (eg res/gz-Na.021).
Each time the program is runs will have a unique UUID number that
is included in all output in a single run as an extra check.

The program is designed to run well with a batch queueing system 
supporting jobarrays by taking the run number as a commandline argument.
The job array number can then be used to directly select a corresponding
input file.  The program also responds to the TERM signal, which 
causes the program to attempt to save the lastest state before exiting.

+ How to compile +

**NOTE** This code has been tested only with the Intel and GNU
compiler collection.

+ Requirements +

* Fortran + C++ compilation environment.

* BLAS/Lapack library.

* (Optional) Optimised random number generator library.

+ Operation +

There is no automatic configuration and build system.  Instead the
user needs to follow a few steps to configure the software for
their system.  This should be achievable by someone familiar with
writing and compiling software using makefiles.  The build system
consists of a driver makefile which reads a user-defined "local.mk"
file that specifies the components to use.  This is done in the 
'local.mk' file by including the relevant "{option}.mk" file. Ideally
only the 'local.mk' file should need to be edited if using the
supported libraries.

* Required components

** Compiler suite to use: We include "gcc.mk" and "intel.mk" as
example files for the Gnu Compiler Collection and Intel compilers.
If you use these compilers you may be able to use the example
file. Note that the optimisation options are selected to give the
fastest, numerically stable results for these compilers.

** Math library to use: We include 'atlas.mk', 'gsl.mk' and 'mkl.mk'
example files for the Atlas, Gnu Scientific Library and Intel Maths
Kernel Library.

** Random number generation: The library now defaults to using the
C++-11 random numbers. The code is also configured for the SFMT or
dSFMT libraries ('sfmt.mk') if C++ random numbers is not available.

+ Step-by-step walk through +

We recommend compiling in a separate directory.  This describes
the process on a Unix-like OS (first two steps already done as 
BUILD/unix).

* Create a build directory: eg BUILD

 $ mkdir BUILD

* Link the contents of the source directory into this directory.

 $ cd BUILD
 $ ln -s ../TRUNK/* .

* If required, download and install any optional libraries you wish to use

**  The C++ std::tr1::mersenne_twister is the default option. If this
  is not available we recommend dSFMT.  Note that the random
  number generator is accessed via the C++ iterface file
  'cutil.cpp'.  To use another random number library you need to
  provide implementations of seedrand and genrand in this file.
  The seedrand method will be called with an integer to use as the
  random number seed, it can also perform any library initialisation.
  The genrand function takes no arguments and is expected to return
  a value in the range 0 to 1.

  [DSFMT at: http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/]

** For BLAS library we the code includes support for Intel's MKL or ATLAS.
  GSL is also supported as the implementation is rigorously correct but
  it is not optimised.  As the core BLAS kernel used is GEMM the
  unoptimised GSL will be very much slower than the other libraries,
  and this gets worse as data size increases.  Note that I do not
  have access to an ACML library so you will need to create an
  'acml.mk' file with the necessary settings.

  [ACML (free) at :
  http://developer.amd.com/libraries/acml/pages/default.aspx]

  [ATLAS (free) at : http://math-atlas.sourceforge.net/]

  [MKL at : http://www.intel.com/software/products/mkl/]

* Create a copy of the local makefile from the template

 $ cp local.tmpl local.mk

* Edit local.mk for your environment.

** To create a statically linked executable uncomment the
  'static_build:=true' line.  Building a static executable will
  almost always require you to supply more detailed settings than
  a dynamic version.  I therefore recommend building the dynamic
  version first and testing the program compiles successfully before
  trying to build a static version.

** select which compiler and math libraries to use by
  including appropriate '{option}.mk' file. This might just require
  you to uncomment lines in the 'local.mk' file.

*** Look in the '{option}.mk" files to determine any settings you
  may need to override in local.mk.  For example MKLROOTDIRS can be set
  in local.mk if the value in mkl.mk does not contain the directory
  of your installed MKL libraries.

* Compile the program.  Note that 'make' will generate a new
  'vers.f90' file every time it is run so that this file can contain
  the current date and compiler settings.

 $ make channel

** There may be some 'uninitialised variable' warnings about unused
  arguments and temporaries.  We have carefully checked that in the
  particular cases here we see that these warnings must be ignored.

** To create a less optimised debug version you can use:

 $ make VARIANT=DEBUG channel

** To include extra code that provides runtime debugging information
  edit 'const.f90' and set dbc=.true. and/or debug=.true.

*** The 'dbc' variable includes extra runtime tests of the data of the
  running program that can detect programming errors as early
  as possible.

*** The 'debug' variable includes extra code to print out _lots_ of
  runtime messages about the running program.

*** Both of these can be used with the optimised program.

** To remove unneeded intermediate files after compilation use
  the 'clean' make target

 $ make clean

** To remove all temporary files and the executable use the
  'distclean' make target

 $ make distclean

* If the program compiled successfully the program is ready to
  be used.  Look in the 'DOC' subdirectory for some basic
  instructions.  Look in the 'EXAMPLE' directory for some example
  input files.

  For example:
  $ cd ../../EXAMPLE
  $ cat README
  $ ../BUILD/unix/channel 1

  (Wait for 7 days....
   Maybe drink coffee??)
_________________________________________________________________________

+ Frequent compilation errors +

Compilation errors may come from misconfiguration. Our configuration
scheme works by putting all compiler/library differences into
the 'cutil.cpp' C++ file and selects between them using the C
preprocessor.

(*) '.../gcc-4.2' no such executable.

The 'local.tmpl' template specifies the GCC compiler version in
the makefile variable "GCCVER". Try removing this line
or specify s version you have and want to use.

(*) multiple or no declaration of the 'llrint' function.

Examining the 'cutil.cpp' file we see it includes a declaration of
this function inside an '#ifndef HAVE_LLRINT' directive.  Thus we may
need to add or remove this preprocessor flag to the 'CXXFLAGS+=...'
line in 'local.mk'.

(*) 'isnan' has no type/definition.

In some fortran compilers the 'isnan' function is not implicitly 
included. If there is no compiler option to include it, this
can be fixed by adding '-DHAVE_NO_IMPLICIT_ISNAN' to 'FFLAGS+=...'

(*) undefined reference to 'uuid_generate' function.  

In some environments the UUID library is automatically included, in others it 
must be manually included. To manually add it, add 'LDFLAGS+=-luuid '
to 'local.mk'. The library is specifically the libuuid library from util-linux.


(*) missing header files

Check that the include directories of the library you want to use are
correct in the actual command line used. If not then you may need to
add definitions to the 'local.mk' or '{option}.mk' files.

uuid/uuid.h is from libuuid

(*) missing libraries

This has several causes. Firstly check the library name on the
command line matches the installed library name; for example the
ATLAS library can have different names on different systems. Secondly
check the directory on the command line is correct. In particular
check that the specific library subdirectory is correct; for example
(older) MKL library had subdirectories '32' 'em64t' and '64' for
32 bit, 64 bit and ia64 versions.

ATLAS tends to be installed in a variety of ways. If the atlas.mk
variables don't pick up atlas, you may need to hard-code LAPACKLIB
after 'include atlas.mk' to override the libraries to link and the
path, as in 'LAPACKLIB:=-L/usr/lib64/atlas -lsatlas' for example.

+ Using another library +

The program uses a fairly standard interface to Lapack and random
number generator routines which can be supplied by a range of
alternative libraries.  If we do not include a particular library
(eg GOTO or TRNG) you want to use follow these guidelines to add
the library.  Configuration for a particular compiler or library is
split between a makefile such as 'mkl.mk' and the 'cutil.cpp' file.

In the makefile you define the header and library paths to the
library. You also include a C preprocessor directive similar to
the directive '-DUSE_MKL' for the MKL library.  This directive is
then used in the 'cutil.cpp' file to select the code to include
the library.

Each library needs to write 'C/C++' adapter functions that
translate between the library's interface and the interface used
in the program.  We do not use the preprocessor in Fortran where
it is non-standard, so we must write the adapters in 'C/C++'.
The usual care must be taken to consider C to Fortran conversions
where necessary.

* A new random number generator library requires definition of 
 'seedrand' and 'genrand' functions. The signature of these 
 functions is declared at the top of 'cutil.cpp' and definitions
 for the SFMT and dSFMT library can be used as a guide. You could
 optionally provide an implementation of the 'random_shuffle_int'
 method, which currently defaults to the C++ "std::random_shuffle" 
 method, that uses the new library.

* A new maths library requires a working Lapack module for fortran
 and a 'mathlib_version' function. Included definition of this
 function for the ATLAS library could be used as a guide.

